package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/coder/terraform-provider-coder/v2/provider"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"golang.org/x/xerrors"
)

// This script patches Markdown docs generated by `terraform-plugin-docs` to:
// 1. Expose the original deprecation message
// 2. Add minimum Coder version requirements

const docsDir = "docs" // FIXME expose as flag?

var reDeprecatedProperty = regexp.MustCompile("`([^`]+)` \\(([^,\\)]+), Deprecated\\) ([^\n]+)")

func main() {
	p := provider.New()
	err := exposeDeprecationMessage(p)
	if err != nil {
		log.Fatal(err)
	}
	
	// Add version information to all resources and data sources
	err = addVersionInformation(p)
	if err != nil {
		log.Fatal(err)
	}
}

func exposeDeprecationMessage(p *schema.Provider) error {
	// Patch data-sources
	for dataSourceName, dataSource := range p.DataSourcesMap {
		docFile := filepath.Join(docsDir, "data-sources", strings.Replace(dataSourceName, "coder_", "", 1)+".md")

		err := adjustDocFile(docFile, dataSource.Schema)
		if err != nil {
			return xerrors.Errorf("unable to adjust data-source doc file (data-source: %s): %w", dataSourceName, err)
		}
	}

	// Patch resources
	for resourceName, resource := range p.ResourcesMap {
		docFile := filepath.Join(docsDir, "resources", strings.Replace(resourceName, "coder_", "", 1)+".md")

		err := adjustDocFile(docFile, resource.Schema)
		if err != nil {
			return xerrors.Errorf("unable to adjust resource doc file (resource: %s): %w", resourceName, err)
		}
	}

	// Patch index
	docFile := filepath.Join(docsDir, "index.md")
	err := adjustDocFile(docFile, p.Schema)
	if err != nil {
		return xerrors.Errorf("unable to adjust index doc file: %w", err)
	}
	return nil
}

func adjustDocFile(docPath string, schemas map[string]*schema.Schema) error {
	doc, err := os.ReadFile(docPath)
	if err != nil {
		return xerrors.Errorf("can't read the source doc file: %w", err)
	}

	result := writeDeprecationMessage(doc, schemas)

	err = os.WriteFile(docPath, result, 0644)
	if err != nil {
		return xerrors.Errorf("can't write modified doc file: %w", err)
	}
	return nil
}

func writeDeprecationMessage(doc []byte, schemas map[string]*schema.Schema) []byte {
	return reDeprecatedProperty.ReplaceAllFunc(doc, func(m []byte) []byte {
		matches := reDeprecatedProperty.FindSubmatch(m)
		propertyName := matches[1]
		description := matches[3]

		sch := schemas[string(propertyName)]
		if string(description) != sch.Description {
			log.Printf("warn: same property name `%s` but description does not match, most likely a different property", propertyName)
			return m
		}
		return bytes.Replace(m, []byte("Deprecated"), []byte(fmt.Sprintf("**Deprecated**: %s", sch.Deprecated)), 1)
	})
}

func addVersionInformation(p *schema.Provider) error {
	// Add version info to data sources
	for dataSourceName := range p.DataSourcesMap {
		docFile := filepath.Join(docsDir, "data-sources", strings.Replace(dataSourceName, "coder_", "", 1)+".md")
		if err := addVersionToDoc(docFile, dataSourceName); err != nil {
			return xerrors.Errorf("unable to add version to data-source doc file (data-source: %s): %w", dataSourceName, err)
		}
	}

	// Add version info to resources
	for resourceName := range p.ResourcesMap {
		docFile := filepath.Join(docsDir, "resources", strings.Replace(resourceName, "coder_", "", 1)+".md")
		if err := addVersionToDoc(docFile, resourceName); err != nil {
			return xerrors.Errorf("unable to add version to resource doc file (resource: %s): %w", resourceName, err)
		}
	}

	return nil
}

func addVersionToDoc(docPath string, resourceName string) error {
	version, ok := provider.ResourceVersions[resourceName]
	if !ok {
		return xerrors.Errorf("no version information found for %s. Please add it to provider.ResourceVersions", resourceName)
	}

	doc, err := os.ReadFile(docPath)
	if err != nil {
		return xerrors.Errorf("can't read the doc file: %w", err)
	}

	docStr := string(doc)
	
	// Check if version note already exists
	if strings.Contains(docStr, "~> **Note:** This") && strings.Contains(docStr, "requires") && strings.Contains(docStr, "Coder") {
		// Version note already exists, skip
		return nil
	}
	
	// Add version note after the description
	versionNote := fmt.Sprintf("\n\n~> **Note:** This %s requires [Coder %s](https://github.com/coder/coder/releases/tag/%s) or later.",
		getResourceType(resourceName), version, version)
	
	// Find the end of frontmatter
	frontmatterEnd := -1
	lines := strings.Split(docStr, "\n")
	
	if len(lines) > 0 && lines[0] == "---" {
		for i := 1; i < len(lines); i++ {
			if lines[i] == "---" {
				frontmatterEnd = i
				break
			}
		}
	}
	
	// Find where to insert the version note
	inserted := false
	for i := frontmatterEnd + 1; i < len(lines); i++ {
		// Skip empty lines and headings
		if lines[i] == "" || strings.HasPrefix(lines[i], "#") {
			continue
		}
		
		// Insert after the first paragraph (non-empty, non-heading line)
		lines[i] = lines[i] + versionNote
		inserted = true
		break
	}
	
	if !inserted {
		// If we couldn't find a good place, add it at the end
		lines = append(lines, versionNote)
	}
	
	docStr = strings.Join(lines, "\n")

	err = os.WriteFile(docPath, []byte(docStr), 0644)
	if err != nil {
		return xerrors.Errorf("can't write modified doc file: %w", err)
	}
	return nil
}

func getResourceType(name string) string {
	if strings.Contains(name, "data_source") || strings.Contains(name, "workspace") || strings.Contains(name, "provisioner") || strings.Contains(name, "parameter") || strings.Contains(name, "external_auth") {
		return "data source"
	}
	return "resource"
}

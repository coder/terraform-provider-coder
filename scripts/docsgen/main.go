package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/coder/terraform-provider-coder/v2/provider"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"golang.org/x/xerrors"
)

// This script patches Markdown docs generated by `terraform-plugin-docs` to:
// 1. Expose the original deprecation message
// 2. Extract and format version information from resource/attribute descriptions
// 3. Add inline version markers for attributes with version requirements

const docsDir = "docs" // FIXME expose as flag?

var (
	reDeprecatedProperty = regexp.MustCompile("`([^`]+)` \\(([^,\\)]+), Deprecated\\) ([^\n]+)")
	// Pattern to extract version info from descriptions: @since:v2.16.0
	reVersionPattern = regexp.MustCompile(`@since:(v\d+\.\d+\.\d+)`)
	// Pattern to find existing version info in descriptions (to clean up)
	reExistingVersionInfo = regexp.MustCompile(`\s*\(@since:[^)]+\)|\s*\(minimum Coder version:[^)]+\)`)
)

func main() {
	p := provider.New()
	err := exposeDeprecationMessage(p)
	if err != nil {
		log.Fatal(err)
	}
	
	// Process version information for all resources and data sources
	err = processVersionInformation(p)
	if err != nil {
		log.Fatal(err)
	}
}

func exposeDeprecationMessage(p *schema.Provider) error {
	// Patch data-sources
	for dataSourceName, dataSource := range p.DataSourcesMap {
		docFile := filepath.Join(docsDir, "data-sources", strings.Replace(dataSourceName, "coder_", "", 1)+".md")

		err := adjustDocFile(docFile, dataSource.Schema)
		if err != nil {
			return xerrors.Errorf("unable to adjust data-source doc file (data-source: %s): %w", dataSourceName, err)
		}
	}

	// Patch resources
	for resourceName, resource := range p.ResourcesMap {
		docFile := filepath.Join(docsDir, "resources", strings.Replace(resourceName, "coder_", "", 1)+".md")

		err := adjustDocFile(docFile, resource.Schema)
		if err != nil {
			return xerrors.Errorf("unable to adjust resource doc file (resource: %s): %w", resourceName, err)
		}
	}

	// Patch index
	docFile := filepath.Join(docsDir, "index.md")
	err := adjustDocFile(docFile, p.Schema)
	if err != nil {
		return xerrors.Errorf("unable to adjust index doc file: %w", err)
	}
	return nil
}

func adjustDocFile(docPath string, schemas map[string]*schema.Schema) error {
	doc, err := os.ReadFile(docPath)
	if err != nil {
		return xerrors.Errorf("can't read the source doc file: %w", err)
	}

	result := writeDeprecationMessage(doc, schemas)
	
	// Clean @since markers from the final documentation
	result = cleanVersionMarkers(result)

	err = os.WriteFile(docPath, result, 0644)
	if err != nil {
		return xerrors.Errorf("can't write modified doc file: %w", err)
	}
	return nil
}

func writeDeprecationMessage(doc []byte, schemas map[string]*schema.Schema) []byte {
	return reDeprecatedProperty.ReplaceAllFunc(doc, func(m []byte) []byte {
		matches := reDeprecatedProperty.FindSubmatch(m)
		propertyName := matches[1]
		description := matches[3]

		sch := schemas[string(propertyName)]
		if string(description) != sch.Description {
			log.Printf("warn: same property name `%s` but description does not match, most likely a different property", propertyName)
			return m
		}
		return bytes.Replace(m, []byte("Deprecated"), []byte(fmt.Sprintf("**Deprecated**: %s", sch.Deprecated)), 1)
	})
}

// cleanVersionMarkers removes @since markers from the documentation
func cleanVersionMarkers(doc []byte) []byte {
	// Remove @since:vX.Y.Z patterns from the documentation
	result := reVersionPattern.ReplaceAll(doc, []byte(""))
	// Clean up any extra spaces that might be left
	result = regexp.MustCompile(`\s+`).ReplaceAll(result, []byte(" "))
	// Clean up trailing spaces at end of lines
	result = regexp.MustCompile(` +\n`).ReplaceAll(result, []byte("\n"))
	return result
}

func processVersionInformation(p *schema.Provider) error {
	// Process data sources
	for dataSourceName, dataSource := range p.DataSourcesMap {
		docFile := filepath.Join(docsDir, "data-sources", strings.Replace(dataSourceName, "coder_", "", 1)+".md")
		
		// Extract version from description
		version := extractVersionFromDescription(dataSource.Description)
		if version != "" {
			// Only add version note if explicitly specified
			if err := addVersionToResourceDoc(docFile, dataSourceName, version, "data source"); err != nil {
				return xerrors.Errorf("unable to add version to data-source doc file (data-source: %s): %w", dataSourceName, err)
			}
		}
		
		// Process attributes for version info
		if err := processAttributeVersions(docFile, dataSource.Schema); err != nil {
			return xerrors.Errorf("unable to process attribute versions for data-source (data-source: %s): %w", dataSourceName, err)
		}
	}

	// Process resources
	for resourceName, resource := range p.ResourcesMap {
		docFile := filepath.Join(docsDir, "resources", strings.Replace(resourceName, "coder_", "", 1)+".md")
		
		// Extract version from description
		version := extractVersionFromDescription(resource.Description)
		if version != "" {
			// Only add version note if explicitly specified
			if err := addVersionToResourceDoc(docFile, resourceName, version, "resource"); err != nil {
				return xerrors.Errorf("unable to add version to resource doc file (resource: %s): %w", resourceName, err)
			}
		}
		
		// Process attributes for version info
		if err := processAttributeVersions(docFile, resource.Schema); err != nil {
			return xerrors.Errorf("unable to process attribute versions for resource (resource: %s): %w", resourceName, err)
		}
	}

	return nil
}

func extractVersionFromDescription(description string) string {
	matches := reVersionPattern.FindStringSubmatch(description)
	if len(matches) > 1 {
		return matches[1]
	}
	return ""
}

func addVersionToResourceDoc(docPath string, resourceName string, version string, resourceType string) error {
	doc, err := os.ReadFile(docPath)
	if err != nil {
		return xerrors.Errorf("can't read the doc file: %w", err)
	}

	docStr := string(doc)
	
	// Check if version note already exists
	if strings.Contains(docStr, "~> **Note:** This") && strings.Contains(docStr, "requires") && strings.Contains(docStr, "Coder") {
		// Version note already exists, skip
		return nil
	}
	
	// Add version note after the description
	versionNote := fmt.Sprintf("\n\n~> **Note:** This %s requires [Coder %s](https://github.com/coder/coder/releases/tag/%s) or later.",
		resourceType, version, version)
	
	// Find the end of frontmatter
	frontmatterEnd := -1
	lines := strings.Split(docStr, "\n")
	
	if len(lines) > 0 && lines[0] == "---" {
		for i := 1; i < len(lines); i++ {
			if lines[i] == "---" {
				frontmatterEnd = i
				break
			}
		}
	}
	
	// Find where to insert the version note
	inserted := false
	for i := frontmatterEnd + 1; i < len(lines); i++ {
		// Skip empty lines and headings
		if lines[i] == "" || strings.HasPrefix(lines[i], "#") {
			continue
		}
		
		// Insert after the first paragraph (non-empty, non-heading line)
		lines[i] = lines[i] + versionNote
		inserted = true
		break
	}
	
	if !inserted {
		// If we couldn't find a good place, add it at the end
		lines = append(lines, versionNote)
	}
	
	docStr = strings.Join(lines, "\n")

	err = os.WriteFile(docPath, []byte(docStr), 0644)
	if err != nil {
		return xerrors.Errorf("can't write modified doc file: %w", err)
	}
	return nil
}

func processAttributeVersions(docPath string, schemas map[string]*schema.Schema) error {
	doc, err := os.ReadFile(docPath)
	if err != nil {
		return xerrors.Errorf("can't read the doc file: %w", err)
	}

	docStr := string(doc)
	modified := false
	
	// Process each attribute that has version information
	for attrName, attrSchema := range schemas {
		version := extractVersionFromDescription(attrSchema.Description)
		if version != "" && version != "v2.18.0" { // Only add version markers for non-default versions
			// Clean the version pattern from the description in the docs
			cleanDesc := reExistingVersionInfo.ReplaceAllString(attrSchema.Description, "")
			cleanDesc = reVersionPattern.ReplaceAllString(cleanDesc, "")
			
			// Find the attribute in the documentation and add version marker
			// Look for patterns like "- `attrName` (Type) Description"
			attrPattern := regexp.MustCompile(fmt.Sprintf(`- \x60%s\x60 \([^)]+\) ([^\n]+)`, regexp.QuoteMeta(attrName)))
			
			newDocStr := attrPattern.ReplaceAllStringFunc(docStr, func(match string) string {
				// Check if version marker already exists
				if strings.Contains(match, "*(since") {
					return match
				}
				// Clean version patterns from the description
				cleanMatch := reVersionPattern.ReplaceAllString(match, "")
				cleanMatch = reExistingVersionInfo.ReplaceAllString(cleanMatch, "")
				// Add version marker at the end
				return strings.TrimRight(cleanMatch, " ") + fmt.Sprintf(" *(since %s)*", version)
			})
			
			if newDocStr != docStr {
				docStr = newDocStr
				modified = true
			}
			
			// Also handle nested attributes (e.g., in blocks)
			// Look for patterns like "  - `attrName` (Type) Description" (with more spaces)
			nestedAttrPattern := regexp.MustCompile(fmt.Sprintf(`(  +)- \x60%s\x60 \([^)]+\) ([^\n]+)`, regexp.QuoteMeta(attrName)))
			
			newDocStr = nestedAttrPattern.ReplaceAllStringFunc(docStr, func(match string) string {
				// Check if version marker already exists
				if strings.Contains(match, "*(since") {
					return match
				}
				// Clean version patterns from the description
				cleanMatch := reVersionPattern.ReplaceAllString(match, "")
				cleanMatch = reExistingVersionInfo.ReplaceAllString(cleanMatch, "")
				// Add version marker at the end
				return strings.TrimRight(cleanMatch, " ") + fmt.Sprintf(" *(since %s)*", version)
			})
			
			if newDocStr != docStr {
				docStr = newDocStr
				modified = true
			}
		}
	}
	
	if modified {
		// Clean any remaining @since markers from the final document
		cleanedDoc := cleanVersionMarkers([]byte(docStr))
		err = os.WriteFile(docPath, cleanedDoc, 0644)
		if err != nil {
			return xerrors.Errorf("can't write modified doc file: %w", err)
		}
	}
	
	return nil
}

package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/coder/terraform-provider-coder/v2/provider"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"golang.org/x/xerrors"
)

// This script patches Markdown docs generated by `terraform-plugin-docs` to:
// 1. Expose the original deprecation message
// 2. Extract and format version information from resource/attribute descriptions
// 3. Add inline version markers for attributes with version requirements

const docsDir = "docs" // FIXME expose as flag?

var (
	reDeprecatedProperty = regexp.MustCompile("`([^`]+)` \\(([^,\\)]+), Deprecated\\) ([^\n]+)")
	// Pattern to extract version info from descriptions: @since:v2.16.0
	reVersionPattern = regexp.MustCompile(`@since:(v\d+\.\d+\.\d+)`)
	// Pattern to find existing version info in descriptions (to clean up)
	reExistingVersionInfo = regexp.MustCompile(`\s*\(@since:[^)]+\)|\s*\(minimum Coder version:[^)]+\)`)
	// Pattern for version note marker (for idempotent updates)
	reVersionNoteMarker = regexp.MustCompile(`<!-- version-note:(v\d+\.\d+\.\d+) -->`)
)

func main() {
	p := provider.New()
	err := exposeDeprecationMessage(p)
	if err != nil {
		log.Fatal(err)
	}

	// Process version information for all resources and data sources
	err = processVersionInformation(p)
	if err != nil {
		log.Fatal(err)
	}
}

func exposeDeprecationMessage(p *schema.Provider) error {
	// Patch data-sources
	for dataSourceName, dataSource := range p.DataSourcesMap {
		docFile := filepath.Join(docsDir, "data-sources", strings.Replace(dataSourceName, "coder_", "", 1)+".md")

		err := adjustDocFile(docFile, dataSource.Schema)
		if err != nil {
			return xerrors.Errorf("unable to adjust data-source doc file (data-source: %s): %w", dataSourceName, err)
		}
	}

	// Patch resources
	for resourceName, resource := range p.ResourcesMap {
		docFile := filepath.Join(docsDir, "resources", strings.Replace(resourceName, "coder_", "", 1)+".md")

		err := adjustDocFile(docFile, resource.Schema)
		if err != nil {
			return xerrors.Errorf("unable to adjust resource doc file (resource: %s): %w", resourceName, err)
		}
	}

	// Patch index
	docFile := filepath.Join(docsDir, "index.md")
	err := adjustDocFile(docFile, p.Schema)
	if err != nil {
		return xerrors.Errorf("unable to adjust index doc file: %w", err)
	}
	return nil
}

func adjustDocFile(docPath string, schemas map[string]*schema.Schema) error {
	doc, err := os.ReadFile(docPath)
	if err != nil {
		return xerrors.Errorf("can't read the source doc file: %w", err)
	}

	result := writeDeprecationMessage(doc, schemas)

	// Clean @since markers from the final documentation
	result = cleanVersionMarkers(result)

	err = os.WriteFile(docPath, result, 0644)
	if err != nil {
		return xerrors.Errorf("can't write modified doc file: %w", err)
	}
	return nil
}

func writeDeprecationMessage(doc []byte, schemas map[string]*schema.Schema) []byte {
	return reDeprecatedProperty.ReplaceAllFunc(doc, func(m []byte) []byte {
		matches := reDeprecatedProperty.FindSubmatch(m)
		propertyName := matches[1]
		description := matches[3]

		sch := schemas[string(propertyName)]
		if string(description) != sch.Description {
			log.Printf("warn: same property name `%s` but description does not match, most likely a different property", propertyName)
			return m
		}
		return bytes.Replace(m, []byte("Deprecated"), []byte(fmt.Sprintf("**Deprecated**: %s", sch.Deprecated)), 1)
	})
}

// cleanVersionMarkers removes @since markers from the documentation
func cleanVersionMarkers(doc []byte) []byte {
	// Remove @since:vX.Y.Z patterns from the documentation
	result := reVersionPattern.ReplaceAll(doc, []byte(""))
	// Clean up any double spaces that might be left after removing @since markers
	result = regexp.MustCompile(`  +`).ReplaceAll(result, []byte(" "))
	// Clean up trailing spaces at end of lines
	result = regexp.MustCompile(` +$`).ReplaceAllFunc(result, func(m []byte) []byte {
		return []byte{}
	})
	return result
}

func processVersionInformation(p *schema.Provider) error {
	// Process data sources
	for dataSourceName, dataSource := range p.DataSourcesMap {
		docFile := filepath.Join(docsDir, "data-sources", strings.Replace(dataSourceName, "coder_", "", 1)+".md")

		// Extract version from description
		version := extractVersionFromDescription(dataSource.Description)
		if version != "" {
			// Only add version note if explicitly specified
			if err := addVersionToResourceDoc(docFile, dataSourceName, version, "data source"); err != nil {
				return xerrors.Errorf("unable to add version to data-source doc file (data-source: %s): %w", dataSourceName, err)
			}
		}

		// Process attributes for version info
		if err := processAttributeVersions(docFile, dataSource.Schema); err != nil {
			return xerrors.Errorf("unable to process attribute versions for data-source (data-source: %s): %w", dataSourceName, err)
		}
	}

	// Process resources
	for resourceName, resource := range p.ResourcesMap {
		docFile := filepath.Join(docsDir, "resources", strings.Replace(resourceName, "coder_", "", 1)+".md")

		// Extract version from description
		version := extractVersionFromDescription(resource.Description)
		if version != "" {
			// Only add version note if explicitly specified
			if err := addVersionToResourceDoc(docFile, resourceName, version, "resource"); err != nil {
				return xerrors.Errorf("unable to add version to resource doc file (resource: %s): %w", resourceName, err)
			}
		}

		// Process attributes for version info
		if err := processAttributeVersions(docFile, resource.Schema); err != nil {
			return xerrors.Errorf("unable to process attribute versions for resource (resource: %s): %w", resourceName, err)
		}
	}

	return nil
}

func extractVersionFromDescription(description string) string {
	matches := reVersionPattern.FindStringSubmatch(description)
	if len(matches) > 1 {
		return matches[1]
	}
	return ""
}

func isValidVersion(version string) bool {
	// Check if version matches vX.Y.Z format and is >= v2.0.0
	matches := regexp.MustCompile(`^v(\d+)\.(\d+)\.(\d+)$`).FindStringSubmatch(version)
	if len(matches) < 2 {
		return false
	}
	var major int
	fmt.Sscanf(matches[1], "%d", &major)
	if major < 2 {
		log.Printf("warn: version %s is before baseline v2.0.0", version)
		return false
	}
	return true
}

func addVersionToResourceDoc(docPath string, resourceName string, version string, resourceType string) error {
	// Validate version format
	if !isValidVersion(version) {
		log.Printf("warn: invalid version format %s for %s", version, resourceName)
		return nil
	}

	doc, err := os.ReadFile(docPath)
	if err != nil {
		return xerrors.Errorf("can't read the doc file: %w", err)
	}

	docStr := string(doc)

	// Check if version note already exists with marker
	existingMatches := reVersionNoteMarker.FindStringSubmatch(docStr)
	if len(existingMatches) > 0 {
		existingVersion := existingMatches[1]
		if existingVersion == version {
			// Same version, no update needed
			return nil
		}
		// Different version - update the note
		notePattern := regexp.MustCompile(`<!-- version-note:[^>]+ -->\n~> \*\*Note:\*\*[^\n]+\n`)
		versionNote := fmt.Sprintf("<!-- version-note:%s -->\n~> **Note:** This %s requires [Coder %s](https://github.com/coder/coder/releases/tag/%s) or later.\n",
			version, resourceType, version, version)
		docStr = notePattern.ReplaceAllString(docStr, versionNote)
		log.Printf("info: updated %s version note from %s to %s", resourceName, existingVersion, version)
		return os.WriteFile(docPath, []byte(docStr), 0644)
	}

	// Add version note after the description with marker
	versionNote := fmt.Sprintf("\n\n<!-- version-note:%s -->\n~> **Note:** This %s requires [Coder %s](https://github.com/coder/coder/releases/tag/%s) or later.",
		version, resourceType, version, version)

	// Find the end of frontmatter
	frontmatterEnd := -1
	lines := strings.Split(docStr, "\n")

	if len(lines) > 0 && lines[0] == "---" {
		for i := 1; i < len(lines); i++ {
			if lines[i] == "---" {
				frontmatterEnd = i
				break
			}
		}
	}

	// Find where to insert the version note
	inserted := false
	for i := frontmatterEnd + 1; i < len(lines); i++ {
		// Skip empty lines and headings
		if lines[i] == "" || strings.HasPrefix(lines[i], "#") {
			continue
		}

		// Insert after the first paragraph (non-empty, non-heading line)
		lines[i] = lines[i] + versionNote
		inserted = true
		break
	}

	if !inserted {
		// If we couldn't find a good place, add it at the end
		lines = append(lines, versionNote)
	}

	docStr = strings.Join(lines, "\n")

	err = os.WriteFile(docPath, []byte(docStr), 0644)
	if err != nil {
		return xerrors.Errorf("can't write modified doc file: %w", err)
	}
	return nil
}

func processAttributeVersions(docPath string, schemas map[string]*schema.Schema) error {
	doc, err := os.ReadFile(docPath)
	if err != nil {
		return xerrors.Errorf("can't read the doc file: %w", err)
	}

	docStr := string(doc)
	modified := false

	// Process each attribute that has version information
	for attrName, attrSchema := range schemas {
		version := extractVersionFromDescription(attrSchema.Description)
		if version != "" {
			// Validate version format
			if !isValidVersion(version) {
				log.Printf("warn: invalid version format %s for attribute %s", version, attrName)
				continue
			}

			// Find the attribute in the documentation and add version marker
			// Use anchored regex to match line structure precisely (prevents false matches)
			attrPattern := regexp.MustCompile(fmt.Sprintf(`(?m)^(\s*)- \x60%s\x60 \(([^)]+)\) ([^\n]+)$`, regexp.QuoteMeta(attrName)))

			newDocStr := attrPattern.ReplaceAllStringFunc(docStr, func(match string) string {
				// Check if version marker already exists for this version
				if strings.Contains(match, "*(since "+version+")*") {
					return match
				}
				// Check if it already has a different version marker
				if strings.Contains(match, "*(since v") {
					log.Printf("warn: attribute '%s' already has a version marker, skipping", attrName)
					return match
				}
				// Clean version patterns from the description
				cleanMatch := reVersionPattern.ReplaceAllString(match, "")
				cleanMatch = reExistingVersionInfo.ReplaceAllString(cleanMatch, "")
				// Add version marker at the end
				result := strings.TrimRight(cleanMatch, " ") + fmt.Sprintf(" *(since %s)*", version)
				log.Printf("info: added version marker to attribute '%s': %s", attrName, version)
				return result
			})

			if newDocStr != docStr {
				docStr = newDocStr
				modified = true
			}
		}
	}

	if modified {
		// Clean any remaining @since markers from the final document
		cleanedDoc := cleanVersionMarkers([]byte(docStr))
		err = os.WriteFile(docPath, cleanedDoc, 0644)
		if err != nil {
			return xerrors.Errorf("can't write modified doc file: %w", err)
		}
	}

	return nil
}
